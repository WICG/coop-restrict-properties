<pre class="metadata">
Title: Cross-Origin-Opener-Policy: restrict-properties
Status: CG-DRAFT
Group: WICG
ED: https://github.com/WICG/coop-restrict-properties
Repository: https://github.com/WICG/coop-restrict-properties
Shortname: coop-restrict-properties
Level: 1
Editor: Camille Lamy, Google, clamy@google.com
Abstract:
  This proposal explores a new Cross-Origin-Opener-Policy value, "restrict-properties",
  that would enable crossOriginIsolated while preserving cross-origin popup
  access to a subset of WindowProxy methods.
Indent: 2
Work Status: exploring
Boilerplate: omit conformance
Markup Shorthands: css off, markdown on
WPT Display: inline
</pre>

<pre boilerplate="copyright">&copy;2023, Google, Inc. All rights reserved.</pre>

<pre class="biblio">
{
  "spectre": {
    "authors": [
      "Paul Kocher",
      "Jann Horn",
      "Anders Fogh",
      "Daniel Genkin",
      "Daniel Gruss",
      "Werner Haas",
      "Mike Hamburg",
      "Moritz Lipp",
      "Stefan Mangard",
      "Thomas Prescher",
      "Michael Schwarz",
      "Yuval Yarom"
    ],
    "href": "https://spectreattack.com/spectre.pdf",
    "title": "Spectre Attacks: Exploiting Speculative Execution"
  },

  "COEP": {
    "authors": [
      "Mike West"
    ],
    "href": "https://wicg.github.io/cross-origin-embedder-policy/",
    "title": "COEP"
  },

  "WhyCoopCoep": {
    "authors": [
      "Eiji Kitamura",
      "Demenic Denicola"
    ],
    "href": "https://web.dev/why-coop-coep/",
    "title": "Why you need \"cross-origin isolated\" for powerful features"
  },

  "SecurityPrivacyQuestionnaire": {
    "authors": [
      "Theresa Oâ€™Connor",
      "Pete Snyder",
      "Jason Novak",
      "Lukasz Olejnik",
      "Mike West"
    ],
    "title": "Self-Review Questionnaire: Security and Privacy",
    "href": "https://www.w3.org/TR/security-privacy-questionnaire/"
  }
}
</pre>

<pre class="anchors">
urlPrefix: https://tc39.es/ecma262/; spec: ECMAScript
  text: SharedArrayBuffer; type: interface; url: sec-sharedarraybuffer-objects

urlPrefix: https://infra.spec.whatwg.org/; spec: Infra 
  text: append; type:dfn; url:set-append
  text: contain an entry; type:dfn; url:map-exist
  text: getting the value; type:dfn; url:map-get
  text: list-is-empty; type:dfn; url:list-is-empty
  text: list-remove; type:dfn; url:list-remove
  text: list-size; type:dfn; url:list-size
  text: map-empty; type:dfn; url:map-empty
  text: map-size; type:dfn; url:map-size
  text: map-value; type:dfn; url:map-size
  text: remove entries; type:dfn; url:map-remove
  text: set; type:dfn; url:ordered-set

urlPrefix: https://html.spec.whatwg.org/C/; spec: html
  text: agent cluster key; type:dfn; url:agent-cluster-key
  text: auxilliary browsing context; type:dfn; url:auxilliary-browsing-context
  text: browsing context; type:dfn; url:browsing-context
  text: browsing-context-group; type:dfn; url:browsing-context-group
  text: browsing context group; type:dfn; url:browsing-context-group
  text: browsing context group set; type:dfn; url:browsing-context-group-set
  text: Browsing context group switches due to cross-origin opener policy; type:dfn; url:browsing-context-group-switches-due-to-cross-origin-opener-policy
  text: browsing context set; type:dfn; url:browsing context set
  text: check if an access between two browsing contexts should be reported; type:dfn; url:coop-check-access-report
  text: check if COOP values require a browsing context group switch; type: dfn; url: check-browsing-context-group-switch-coop-value
  text: checking if COOP values require a browsing context group switch; type: dfn; url: check-browsing-context-group-switch-coop-value
  text: check if enforcing report-only COOP would require a browsing context group switch; type: dfn; url: check-bcg-switch-report-only
  text: checking if enforcing report-only COOP would require a browsing context group switch; type: dfn; url: check-bcg-switch-report-only
  text: COEP; type: dfn; url: coep
  text: COOP; type: dfn; url: cross-origin-opener-policies
  text: coop-enforcement-origin; type: dfn; url: coop-enforcement-origin
  text: current context is navigation source; type: dfn; url: coop-enforcement-source
  text: coop-same-origin; type: dfn; url: coop-same-origin
  text: coop-same-origin-allow-popups; type: dfn; url: coop-same-origin-allow-popups
  text: compatible with cross-origin isolation; type: dfn; url:compatible-with-cross-origin-isolation
  text: concept-document-bc; type:dfn; url:concept-document-bc
  text: concept-document-origin; type:dfn; url:concept-document-origin
  text: concept-document-policy-container; type: dfn; url: concept-document-policy-container
  text: concrete; type:dfn; url:cross-origin-isolation-concrete
  text: creating a new browsing context; type:dfn; url:creating-a-new-browsing-context
  text: creating a new browsing context group and document; type:dfn; url:creating-a-new-browsing-context-group-and-document
  text: creating a new top-level browsing context and document; type:dfn; url:creating-a-new-top-level-browsing-context
  text: create a new top-level browsing context and document; type:dfn; url:creating-a-new-top-level-browsing-context
  text: create a new top-level traversable; type:dfn; url:creating-a-new-top-level-traversable
  text: Cross-Origin-Embedder-Policy; type: dfn; url: coep
  text: Cross-Origin-Opener-Policy; type: dfn; url: cross-origin-opener-policies
  text: cross-origin opener policy; type: dfn; url: cross-origin-opener-policy
  text: cross-origin-opener-policy-value; type: dfn; url: cross-origin-opener-policy-value
  text: cross-origin opener policy enforcement result; type: dfn; url:coop-enforcement-result
  text: crossOriginIsolated; type:dfn; url:concept-settings-object-cross-origin-isolated-capability
  text: crossOriginGet; type:dfn; url:crossoriginget-(-o,-p,-receiver-)
  text: crossOriginGetOwnPropertyHelper; type:dfn; url:crossorigingetownpropertyhelper-(-o,-p-)
  text: crossOriginProperties; type:dfn; url:crossoriginproperties-(-o-)
  text: crossOriginSet; type:dfn; url:crossoriginset-(-o,-p,-receiver-)
  text: cross-origin isolation mode; type:dfn; url: bcg-cross-origin-isolation
  text: embedder-policy-report-only-value; type: dfn; url: embedder-policy-report-only-value
  text: embedder-policy-value; type:dfn; url:embedder-policy-value
  text: embedder-policy-value-2; type:dfn; url:embedder-policy-value-2
  text: environment; type:dfn; url:environment
  text: enforce a response's cross-origin opener policy; type:dfn; url:coop-enforce
  text: Grouping of browsing contexts; type:dfn; url:grouping-of-browsing-contexts
  text: Infrastructure for sequences of documents; type:dfn; url:infrastructure-for-sequences-of-documents
  text: Integration with the JavaScript agent cluster formalism; type:dfn; url:integration-with-the-javascript-agent-cluster-formalism
  text: logical; type:dfn; url:cross-origin-isolation-logical
  text: location-getownproperty; type:dfn; url:location-getownproperty
  text: matching-coop; type:dfn; url:matching-coop
  text: needs a browsing context group switch; type:dfn; url: coop-enforcement-bcg-switch
  text: navigation params; type:dfn; url:navigation-params
  text: navigation-params-hh; type:dfn; url:navigation-params-hh
  text: navigation-params-origin; type:dfn; url:navigation-params-origin
  text: coop-enforcement-bcg-switch; type:dfn; url:coop-enforcement-bcg-switch
  text: policy-container-embedder-policy; type: dfn; url: policy-container-embedder-policy
  text: popup sandboxing flag set; type: dfn; url: popup-sandboxing-flag-set
  text: queue a violation report for browsing context group switch when navigating to a COOP response; type:dfn; url:coop-violation-navigation-to
  text: Queue a violation report for browsing context group switch when navigating away from a COOP response; type:dfn; url:coop-violation-navigation-from
  text: obtaining a cross-origin embedder policy; type:dfn; url:obtain-an-embedder-policy
  text: obtain a cross-origin opener policy; type:dfn; url:obtain-coop
  text: obtain a browsing context to use for a navigation response; type:dfn; url:obtain-browsing-context-navigation
  text: origin; type:dfn; url:concept-origin
  text: report-only value; type:dfn; url:coop-struct-report-only-value
  text: removing a top-level browsing context; type:dfn; url:bcg-remove
  text: response; type:dfn; url:concept-response
  text: same-origin-allow-popups; type:dfn; url:coop-same-origin-allow-popups
  text: same-origin-plus-coep; type:dfn; url:coop-same-origin-plus-coep
  text: shared abstract operations; type:dfn; url:shared-abstract-operations
  text: top-level browsing context; type:dfn; url:top-level-browsing-context
  text: same origin; type:dfn; url:same-origin
  text: unsafe-none; type:dfn; url:coop-unsafe-none
  text: virtual browsing context group id; type:dfn; url:virtual-browsing-context-group-id
  text: WindowProxy; type:dfn; url:the-window-proxy-exotic-object
  text: windowproxy-get; type:dfn; url:windowproxy-get
  text: windowproxy-getownproperty; type:dfn; url:windowproxy-getownproperty
  text: windowproxy-set; type:dfn; url:windowproxy-set
  text: windows; type:dfn; url:windows
  text: window open steps; type:dfn; url:window-open-steps
  text: would need a browsing context group switch due to report-only; type:dfn; url:coop-enforcement-bcg-switch-report-only
  <!--text: A; type:dfn; url:A-->
  <!--text: A; type:dfn; url:A-->

urlPrefix: https://webidl.spec.whatwg.org/#LegacyUnenumerableNamedProperties
  text: DOMException; type:dfn; url:dfn-DOMException
  text: LegacyUnenumerableNamedProperties; type:dfn; url:LegacyUnenumerableNamedProperties
  text: SecurityError; type:dfn; url:securityerror

urlPrefix: https://tc39.es/ecma262/#sec-execution-contexts
  text: javascript execution context; type:dfn; url:sec-execution-contexts

text: back/forward cache; type:dfn; url:https://web.dev/bfcache/

</pre>

<pre class="link-defaults">
  spec:fetch; type:dfn; for:/; text:response
  spec:html; type:dfn; for:/; text:origin
  spec:html; type:dfn; for:Window; text:browsing context
  spec:html; type:dfn; for:policy container; text:embedder policy
  spec:html; type:dfn; text:environment
  spec:url; type:dfn; for:/; text:url
</pre>

<style>
.monkey-patch {
    padding: .5em;
    border: thin solid #ddd;
    border: thin solid 1px;
    border-radius: .5em;
    margin: .5em calc(-0.5em - 1px);
    background-color: rgba(255, 255, 0, 0.03);
    backdrop-filter: blur(5px);
    box-shadow: 0px 5px 5px 0px rgba(0, 0, 0, 0.05);
}

.brief {
  line-height: 10%;
}

.customHighlight {
  padding-top:9px ;
  padding-bottom:9px ;
  background-color: rgba(255,255,0,0.3)
}

</style>

Introduction { #introduction }
============

<em>This section is not normative.</em>

Recommended readings {#recommended-readings}
--------------------
- The [[Spectre]] vulnerability.
- The [=Cross-Origin-Opener-Policy=] ([=COOP=]) section of the HTML spec.
- How and why [=Cross-Origin-Opener-Policy=] ([=COOP=]) and
  [=Cross-Origin-Embedder-Policy=] ([=COEP=]) are granting the
  [crossOriginIsolated](concept-settings-object-cross-origin-isolated-capability)
  capability. See [[WhyCoopCoep]].

A problem {#problem}
=========

<em>This section is not normative.</em>

For pages to get
[crossOriginIsolated](concept-settings-object-cross-origin-isolated-capability)
today, we require that [=COOP: same-origin=]([=coop-same-origin=] be set. This
effectively prevents any interaction with third-party popups. This is
problematic for an important variety of use cases, below are a few real world
examples:
- gmail.com wants to do memory measurement to diagnose performance. Some emails
  contain meet.com iframes which open a meeting when interacted with.
- zoom.com wants to use sharedArrayBuffers to reduce the copying of media data.
  It needs to support being opened from third-party apps, via an SDK.
- perfetto.dev, a trace visualization app, would like to use a more accurate
  performance.now() to improve performance. They use third-party popups to
  display traces without having them sent to their server.
- construct.com, an online game engine needs javascript threading for
  performance, but uses another domain for renderer game-preview popups.

All of the aforementioned APIs are gated behind the
[crossOriginIsolated](concept-settings-object-cross-origin-isolated-capability)
capability. This means that all of these websites cannot access them without
breaking their cross-origin popup flows.

These restrictions are due to the [[Spectre]] vulnerability. Because of
Spectre, OS processes are now the only strong security boundary a browser can
enforce.
[crossOriginIsolated](concept-settings-object-cross-origin-isolated-capability)
unlocks powerful APIs that make Spectre vulnerabilities easier to exploit. So
the browser need to be able to put crossOriginIsolated pages in their own
process based on top-level origin. To be able to honor that,
[=Cross-Origin-Opener-Policy=] ([=COOP=]) relies on [=BrowsingContext group=] ([=browsing-context-group=])
switches.

A BrowsingContext (roughly a frame) belongs to a BrowsingContext group. All
documents presented in a BrowsingContext can communicate with other documents
presented in BrowsingContexts in the same BrowsingContext group via javascript.
Additionally, the BrowsingContext group holds a map of origins to Agent
Clusters. All same-origin documents in the same BrowsingContext group are in
the same Agent Cluster. They have synchronous scripting access to each other.
They need to be in the same process.

If a browser does not support SiteIsolation, then all iframes have to be in the
process of the top-level frame. When any frame on the page opens a popup, the
popup also has to be put in the same process. This is because it could contain
frames that same-origin with frames on its opener page. These frames belong to
the same-agent cluster, and must be located in the same process to guarantee
synchronous DOM interactions. In practice, without SiteIsolation, all pages in
a Browsing context group resides in the same process, like in the example
below:

<img alt="payment flow" src="./resources/payment_flow.jpg"></img>

With COOP same-origin, we put the popup in a different BrowsingContext group.
Putting two documents in BrowsingContexts not belonging to the same
BrowsingContext group ensures they are not in the same Agent Cluster, therefore
that they do not need to be in the same process. This allows one of the
documents to safely enable crossOriginIsolation, since the browser is using two
different processes to isolate them.

<img alt="coop solution" src="./resources/coop_solution.jpg"></img>

However, documents in different browsing context groups cannot communicate with
one other. So the payment flow in this example is broken. COOP
restrict-properties aims to preserve some of the communication while ensuring
that documents can be properly process isolated, even without SiteIsolation.

Explainer {#explainer}
=========

<em>This section is not normative.</em>

The COOP: restrict-properties proposal {#coop-restrict-properties-proposal}
--------------------------------

Instead of completely removing scripting capabilities between two pages, we
would like to only restrict synchronous access. This is what requires pages to
be in the same process. Making sure that two pages can never script each other
synchronously ensures that they can safely be put in different processes.

The basic COOP: restrict-properties idea would be to use a single
BrowsingContext group, but to increase the keying of Agent Cluster. We would
have multiple same-origin documents not be able to synchronously script each
other, despite being able to reach each other's Window object.

Instead of increasing Agent Cluster keying, we introduce a new superset of
BrowsingContext group, the CrossOriginOpenerPolicy group. Within this new
group, pages have asynchronous access to each other. This gives us the
following multi-layer structure.

<img alt="coop group" src="./resources/coop_group.jpg"></img>

Putting pages in a different BrowsingContext group but same COOP
BrowsingContext group would be done via a new COOP value, restrict-properties
that would only allow access to asynchronous properties. This makes it possible
to put the two pages in different processes, and to enable crossOriginIsolated
on the first page, as long as it also sets COEP.

To reduce XS-leaks as much as possible, we reduce asynchronous
across-BrowsingContext groups to a very limited set of properties:
{window.closed and window.postMessage()}. This is based on metrics research
that shows that the overwhelming majority of sites only uses these two
properties when interacting with cross-origin popups. This prevents almost all
WindowProxy XS-Leaks.

Fitting COOP: restrict-properties into current algorithm {#coop-rp-current-algo}
--------------------------------

The COOP algorithm works by comparing header values and origins to say compute
whether or not we should use a new BrowsingContext group. This needs to be
opened to an enum return value, containing the following possible outcomes:

1. Stay in the same BrowsingContext group.
2. Stay in the same COOP group, but change BrowsingContext group.
3. Change COOP BrowsingContext group.

Current COOP algorithm returns either 1. or 3. Using COOP: restrict-properties
would yield 2., iff:
- We are navigating between a page setting COOP: unsafe-none from/to a page
  setting COOP: restrict-properties.
- We are navigating between two pages setting COOP: restrict-properties, but
  that have different origins.
- We have a opened a fresh popup from a page that set COOP:
  same-origin-allow-popups to a page that sets COOP: restrict-properties.

Extra requirements for common use cases {#extra-requirements}
--------------------------------

We want COOP: restrict-properties to be as little intrusive as possible while
providing strong guarantees. Imagine the following use case: an authentication
provider uses a navigation flow to provide login with many different providers.
We do not want one of them setting COOP: restrict-properties limiting the
interactions between my-website.com and the provider.

<img alt="auth provider flow" src="./resources/auth_provider_flow.png"></img>

In the above case, the navigation from auth-provider.com to google.auth.com
triggers a BrowsingContext group swap, within the same COOP group. We want to
make sure that the subsequent navigation from google.auth.com to
auth-provider.com reuses the same BrowsingContext group as the initial
auth-provider.com page, to reduce the impact of deploying COOP:
restrict-properties. We call that the reversibility requirement of COOP:
restrict-properties.

To be able to do that, the COOP group needs to hold a map of BrowsingContext
groups, that they can reuse. This map is keyed by: {isCrossOriginIsolated,
hasCoopRestrictProperties, top-level origin or null}. This makes sure that:

- A crossOriginIsolated BrowsingContext group is never reused for another
  origin, nor for a page that does not set COEP.
- A BrowsingContext group containing pages with COOP: restrict-properties is
  not reused for another origin.
- All pages without COOP, within a COOP group, live in the same BrowsingContext
  group.

Alternatives considered {#alternatives}
=======================

<em>This section is not normative.</em>

## Extra-keying on Agent Clusters ## {#extra-keying}

Instead of introducing the context of COOP groups to the spec, we could have
extended the Agent Cluster key in the following way - the agent cluster key is
either:
- a site
- a tuple origin
- a tuple containing an origin, a boolean (crossOriginIsolated) and another
  origin (top-level origin) 

There is no web-observable behavior difference between this solution and the
one proposed in this spec. We do believe that having the COOP group notion
makes the spec easier to follow, which is why we've opted for it. It also
matches the underlying implementation better.

## COOP same-origin-allow-popups-plus-coep ## {#same-origin-allow-popups-plus-coep}

It would be possible to extend Cross-Origin-Opener-Policy:
same-origin-allow-popups to provide the same guarantees as
Cross-Origin-Opener-Policy: restrict-properties in order to support
crossOrignIsolation. However, this has a few drawbacks. First, this can only be
done when a page also sets COEP. Otherwise, the compatibility risk on pages
already deploying COOP same-origin-allow-popups is too high. Second, it would
only allow openers of popups to be crossOriginIsolated, and not popups
themselves. Finally, COOP restrict-properties provides an easy to deploy
mitigation against most WindowProxy based XS-Leaks, that is valuable in itself
even outside the crossOriginIsolation paradigm.

Tests {#tests}
=====

Status:
[https://wpt.fyi/results/html/cross-origin-opener-policy/tentative/restrict-properties](https://wpt.fyi/results/html/cross-origin-opener-policy/tentative/restrict-properties)

Specification {#specification}
=============

This section defines a monkey-patch over [[!HTML]].

## Cross-origin-opener-policies ## {#cross-origin-opener-policies}

### Cross-origin opener policy values ### {#coop-values}

In the [cross-origin opener
policies](https://html.spec.whatwg.org/#cross-origin-opener-policies) section,
extend the possible [=cross-origin-opener-policy-value|cross-origin opener polic values=]: 

<div class="monkey-patch">
<dfn lt="coop-restrict-properties">restrict-properties</dfn>

This forces the [=document=] and its child [=document=] to use [=agent
clusters=] keyed on top-level origin and [=cross-origin isolation mode=]. It
also restricts the [=WindowProxy=] methods available from [=agent clusters=]
with a different top-level origin and [=cross-origin isolation mode=].

<dfn lt="coop-restrict-properties-plus-coep">restrict-properties-plus-coep</dfn>

This behaves the same as "[=coop-restrict-properties=]", with the addition that
it sets the [=top-level browsing context=]'s
[=browsing-context-group|group=] [=cross-origin isolation mode=] to one of
"logical" or "concrete".

</div>

Extend the [=cross-origin opener policy=] definition:

<div class="monkey-patch">
- A <dfn lt="coop-origin">COOP origin</dfn>, which is an [=origin=], initially the empty [=origin=].

</div>

### Obtaining a cross-origin opener policy ### {#obtain-coop}

Modify the [=obtain a cross-origin opener policy=]. First, add an origin parameter:

<div class="monkey-patch">
To [=obtain a cross-origin opener policy=] given a [=response=] *response*, an
[=environment=] *reservedEnvironment*, and an [=origin=] *origin*:
</div>

Then, add a step after step 4.1:

<div class="monkey-patch">
4.2. If *parsedItem*[0] is "[=coop-restrict-properties|restrict-properties=]", then:
  1. Let *coep* be the result of [=obtaining a cross-origin embedder policy=]
     from *response* and *reservedEnvironment*.
  2. If *coep*'s [=embedder-policy-value-2|value=] is [=compatible with
     cross-origin isolation=], then set *policy*'s
     [=cross-origin-opener-policy-value|value=] to
     "[=coop-restrict-properties-plus-coep|restrict-properties-plus-coep=].
  3. Otherwise, set *policy*'s
     [=cross-origin-opener-policy-value|value=] to
     "[=coop-restrict-properties|restrict-properties=].
</div>

Finally, add a step 5:

<div class="monkey-patch">

5. Set *policy*'s [=coop-origin|COOP origin=] to *origin*.

</div>

### Browsing context group switches due to cross-origin opener policy ### {#coop-bcg-switch}

Add a new concept in the [=Browsing context group switches due to cross-origin
opener policy=] part of the spec:

<div class="monkey-patch">

A <dfn lt="coop-enforcement-value">cross-origin opener policy enforcement
value</dfn> indicates whether the enforcement of a [=COOP=] requires a browsing
context group switch and/or to restrict access to the browsing context inside
the browsing context group.

A [=coop-enforcement-value|cross-origin opener policy value=] has a boolean
<dfn lt="coop-enforcement-value-switch">browsingContextGroupSwitchNeeded</dfn>,
initially false.

A [=coop-enforcement-value|cross-origin opener policy value=] has an <dfn
lt="coop-enforcement-value-key">agentClusterKey</dfn>, which is null or a
[=coop-agent-cluster-key|COOP agent cluster key=], initially null.

</div>

The algorithm to [=check if COOP values require a browsing context group switch=] becomes:

<div class="monkey-patch">

1. let *coopEnforcementValue* be a new [=coop-enforcement-value|cross-origin
   opener policy enforcement value=].
2. If any of the following is true:
   - *responseCOOPValue* is "[=coop-restrict-properties|restrict-properties=]";
   - *responseCOOPValue* is
     "[=coop-restrict-properties-plus-coep|restrict-properties-plus-coep=]";
   - *activeDocumentCOOPValue*'s [=cross-origin-opener-policy-value|value=] is
     "[=coop-same-origin|same-origin=]";
   - *activeDocumentCOOPValue*'s [=cross-origin-opener-policy-value|value=] is
     "[=same-origin-plus-coep=]";
   - *responseCOOPValue* is "[=coop-same-origin|same-origin=]";
   - *responseCOOPValue* is "[=same-origin-plus-coep=]";
   - then:
     1. Let *needCrossOriginIsolation* be false.
     2. If *responseCOOPValue* is
        "[=coop-restrict-properties-plus-coep|restrict-properties-plus-coep=]"
        or *responseCOOPValue* is "[=same-origin-plus-coep=]", set
        *needCrossOriginIsolation* to true.
     3. Set *coopEnforcementValue*'s
        [=coop-enforcement-value-key|agentClusterKey=] to [*responseOrigin*,
        *needCrossOriginIsolation*].
3. If the result of [=matching-coop|matching=] *activeDocumentCOOPValue*,
   *activeDocumentNavigationOrigin*, *responseCOOPValue*, and *responseOrigin* is
   true, return *coopEnforcementValue*.
4. If all of the following are true:
   - *isInitialAboutBlank*;
   - *activeDocumentCOOPValue*'s [=cross-origin-opener-policy-value|value=] is
     "[=same-origin-allow-popups=]"; and
   - *responseCOOPValue* is not "[=coop-same-origin|same-origin=]" or
     "[=same-origin-plus-coep=]",
   - then return *coopEnforcementValue*.
5. If any of the following is true: 
   - *activeDocumentCOOPValue*'s [=cross-origin-opener-policy-value|value=] is
     "[=coop-same-origin|same-origin=]";
   - *activeDocumentCOOPValue*'s [=cross-origin-opener-policy-value|value=] is
     "[=same-origin-plus-coep=]";
   - *responseCOOPValue* is "[=coop-same-origin|same-origin=]";
   - *responseCOOPValue* is "[=same-origin-plus-coep=]";
   - then set *coopEnforcementValue*'s
     [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=] to true.
6. Return *coopEnforcementValue*.

</div>

The algorithm to [=check if enforcing report-only COOP would require a browsing
context group switch=] becomes:

<div class="monkey-patch">

1. Let *coopEnforcementValue* be the result of [=checking if COOP values
   require a browsing context group switch=] given *isInitialAboutBlank*,
   *responseOrigin*, *activeDocumentNavigationOrigin*, *responseCOOP*'s
   [=report-only value=] and *activeDocumentCOOPReportOnly*'s [=report-only
   value=]. 
2. If *coopEnforcementValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=]
   is false, then return *coopEnforcementValue*.
3. Let *activeDocumentReportOnlyCOOPEnforcementValue* be the result of
   [=checking if COOP values require a browsing context group switch=] given
   *isInitialAboutBlank*, *responseOrigin*, *activeDocumentNavigationOrigin*,
   *responseCOOP*'s [=cross-origin-opener-policy-value|value=] and
   *activeDocumentCOOPReportOnly*'s [=report-only value=].
4. If *activeDocumentReportOnlyCOOPEnforcementValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=]
   is true, then set *coopEnforcementValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=]
   to true.
5. Let *responseReportOnlyCOOPEnforcementValue* be the result of
   [=checking if COOP values require a browsing context group switch=] given
   *isInitialAboutBlank*, *responseOrigin*, *activeDocumentNavigationOrigin*,
   *responseCOOP*'s [=report-only value=] and
   *activeDocumentCOOPReportOnly*'s [=cross-origin-opener-policy-value|value=].
6. If *responseReportOnlyCOOPEnforcementValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=]
   is true, then set *coopEnforcementValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=]
   to true.
7. Return *coopEnforcementValue*. 

</div>

Change the two first members of the [=cross-origin opener policy enforcement result=]:

<div class="monkey-patch">

- A [=coop-enforcement-value|COOP enforcement value=] [=needs a browsing context
  group switch=].
- A [=coop-enforcement-value|COOP enforcement value=] [=would need a browsing
  context group switch due to report-only=].

</div>

Modify the [=enforce a response's cross-origin opener policy=] algorithm:

<div class="monkey-patch">

4. Let *newCOOPEnforcementResultValue*'s be the result of [=checking if COOP values
   require a browsing context group switch=] given *isInitialAboutBlank*,
   *currentCOOPEnforcementResult*'s [=cross-origin opener policy=]'s
   [=cross-origin-opener-policy-value|value=], *currentCOOPEnforcementResult*'s
   [=origin=], *responseCOOP*'s [=cross-origin-opener-policy-value|value=], and
   *responseOrigin*.
5. Set *newCOOPEnforcementResult*'s [=needs a browsing context group
   switch=]'s [=coop-enforcement-value-key|agentClusterKey=] to
   *newCOOPEnforcementResultValue*'s
   [=coop-enforcement-value-key|agentClusterKey=].
6. If *newCOOPEnforcementResultValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=] is true, then:
   1. Set *newCOOPEnforcementResult*'s [=needs a browsing context group
      switch=]'s [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=]
      to true.
   2. If *browsingContext*'s [=browsing-context-group|group=]'s [=browsing context
      set=]'s [=list-size|size=] is greater than 1, then:
      1. [=Queue a violation report for browsing context group switch when
         navigating to a COOP response=] with *responseCOOP*, "*enforce*", *responseURL*,
         *currentCOOPEnforcementResult*'s [=url=], *currentCOOPEnforcementResult*'s [=origin=],
         *responseOrigin*, and *referrer*.
      2. [=Queue a violation report for browsing context group switch when
         navigating away from a COOP response=] with
         *currentCOOPEnforcementResult*'s [=cross-origin opener policy=]'s , "*enforce*",
         *currentCOOPEnforcementResult*'s [=url=], *responseURL*, *currentCOOPEnforcementResult*'s
         [=coop-enforcement-origin|origin=], *responseOrigin*, and
         *currentCOOPEnforcementResult*'s [=current context is navigation source=].
7. Let *newCOOPEnforcementResultReportOnlyValue* be the result of [=checking if
   enforcing report-only COOP would require a browsing context group switch=]
   given *isInitialAboutBlank*, *responseOrigin*,
   *currentCOOPEnforcementResult*'s [=origin=], *responseCOOP*, and
   *currentCOOPEnforcementResult*'s [=cross-origin opener policy=].
8. Set *newCOOPEnforcementResult*'s [=would need a browsing context group
   switch due to report-only=]'s
   [=coop-enforcement-value-key|agentClusterKey=] to
   *newCOOPEnforcementResultReportOnlyValue*'s
   [=coop-enforcement-value-key|agentClusterKey=].
9. If *newCOOPEnforcementResultReportOnlyValue*'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=] is true, then:
   1. Set *newCOOPEnforcementResult*'s [=would need a browsing context group
      switch due to report-only=]'s
      [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=] to true.
   2. If *browsingContext*'s [=browsing-context-group|group=]'s [=browsing context
      set=]'s [=list-size|size=] is greater than 1, then:
      1. [=Queue a violation report for browsing context group switch when
         navigating to a COOP response=] with *responseCOOP*, "*reporting*", *responseURL*,
         *currentCOOPEnforcementResult*'s [=url=], *currentCOOPEnforcementResult*'s [=origin=],
         *responseOrigin*, and *referrer*.
      2. [=Queue a violation report for browsing context group switch when
         navigating away from a COOP response=] with
         *currentCOOPEnforcementResult*'s [=cross-origin opener policy=]'s , "*reporting*",
         *currentCOOPEnforcementResult*'s [=url=], *responseURL*, *currentCOOPEnforcementResult*'s
         [=coop-enforcement-origin|origin=], *responseOrigin*, and
         *currentCOOPEnforcementResult*'s [=current context is navigation source=].
10. Return *newCOOPEnforcementResult*.

</div>

The [=obtain a browsing context to use for a navigation response=] becomes:

<div class="monkey-patch">

1. If *browsingContext* is not a [=top-level browsing context=], then return
   *browsingContext*.
2. Let *navigationBrowsingContext* be null.
3. If *coopEnforcementResult*'s [=needs a browsing context group switch=]'s
   [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=] is false, then:
   1. If *coopEnforcementResult*'s [=would need a browsing context group switch due
      to report-only=]'s
      [=coop-enforcement-value-switch|browsingContextGroupSwitchNeeded=] is true, set
      *browsingContext*'s [=virtual browsing context group ID=] to a new unique identifier.
   2. Set *navigationBrowsingContext* to *browsingContext*.
4. Else:
   1. Set *navigationBrowsingContext* to the first return value of [=creating a new
      top-level browsing context and document=].
   2. If *sandboxFlags* is not empty, then:
      1. Assert *navigationCOOP*'s [=cross-origin-opener-policy-value|value=] is
         one of "[=unsafe-none=]", "[=coop-restrict-properties|restrict-properties=]", or
         "[=coop-restrict-properties-plus-coep|restrict-properties-plus-coep=]".
      2. Assert *navigationBrowsingContext*'s [=popup sandboxing flag set=] is empty.
      3. Set *navigationBrowsingContext*'s [=popup sandboxing flag set=] to a clone of
         *sandboxFlags*.
5. Set *navigationBrowsingContext*'s [=bcg-coop-agent-cluster-key|COOP agent
   cluster key=] to *coopEnforcementResult*'s [=needs a browsing context group
   switch=]'s [=coop-enforcement-value-key|agentClusterKey=]. 
6. Set *navigationBrowsingContext*'s [=virtual-coop-agent-cluster-key|virtual
   COOP agent cluster key=] to *coopEnforcementResult*'s [=would need a browsing
   context group switch due to report-only=]'s
   [=coop-enforcement-value-key|agentClusterKey=]. 
7. Return *navigationBrowsingContext*.

</div>

### Reporting ### {#coop-reporting}

Modify step 8 of the algorithm to [=check if an access between two browsing
contexts should be reported=] algorithm:

<div class="monkey-patch">

8. If *accessor*'s [=top-level browsing context=]'s [=virtual browsing context
   group ID=] is *accessed*'s [=top-level browsing context=]'s [=virtual browsing
   context group ID=], then:
   1. If *accessor*'s [=top-level browsing context=]'s
      [=virtual-coop-agent-cluster-key|virtual COOP agent cluster key=] is
      *accessed*'s [=top-level browsing context=]'s
      [=virtual-coop-agent-cluster-key|virtual COOP agent cluster key=], then
      return.
   2. If P is an [=unrestricted-cross-origin-property-name|unrestricted
      cross-origin accessible window property name=], then return.

</div>

## APIs related to navigation and session history ## {#coop-navigation-apis}

### Security infrastructure for Window, WindowProxy, and Location objects ### {#coop-security-infracstructure}

Add one argument to the [=CrossOriginGetOwnPropertyHelper=] algorithm:

<div class="monkey-patch">

7.2.1.3.4 CrossOriginGetOWnPropertyHelper(O,P,hasSameCOOPKey)

</div>

Replace step 1 and 2 of the [=CrossOriginGetOwnPropertyHelper=] algorithm:

<div class="monkey-patch">

1. Let *crossOriginKey* be a tuple consisting of the [=current settings object=],
   O's [=relevant settings object=], P, and isCrossBrowsingContext.
2. Let *propertyList* be null.
3. If *hasSameCOOPKey* is true, set *propertyLisy* to
   [=CrossOriginProperties=](O).
4. Else, set *propertyList* to
   [=unrestricted-cross-origin-properties|UnrestrictedCrossOriginProperties=](O).
5. For each *e* of *propertyList*:

</div>

### The WindowProxy exotic object ### {#coop-window-proxy}

Add a step to the [=windowproxy-get|Get=] algorithm:

<div class="monkey-patch">

3. If [=windowproxy-same-coop-key|WindowProxyHasSameCOOPKey(W)=] is
   false, then return ? [=CrossOriginGet=](this, P, V, receiver).

</div>

Add a step to the [=windowproxy-set|Set=] algorithm:

<div class="monkey-patch">

3. If [=windowproxy-same-coop-key|WindowProxyHasSameCOOPKey(W)=] is
   false, then return ? [=CrossOriginSet=](this, P, V, receiver).

</div>

Add a step to the WindowProxy [=windowproxy-getownproperty|GetOwnProperty=]
algorithm:

<div class="monkey-patch">

2. If [=windowproxy-same-coop-key|WindowProxyHasSameCOOPKey(W)=] is
   false, then:
   1. Let *property* be
      [=CrossOriginGetOwnPropertyHelper=](W,P, false).
   2. If *property* is not undefined, then return *property*.
   3. Throw a "[=SecurityError=]" [=DOMException=].

</div>

Modify step 4 of the WindowProxy [=windowproxy-getownproperty|GetOwnProperty=]
algorithm:

<div class="monkey-patch">

4. Let *property* be [=CrossOriginGetOwnPropertyHelper=](W,P, true).

</div>

Add the following to the [=WindowProxy=] section:

<div class="monkey-patch">

7.2.3.11 <dfn
         lt="unrestricted-cross-origin-properties">UnrestrictedCrossOriginProperties(W)</dfn>
         1. Return { [Property]: "*closed*", [NeedsGet]: true, [NeedsSet]:
            false }, { [Property]: "*postMessage*" } Â».

A Javascript property name P is a <dfn
lt="unrestricted-cross-origin-property-name">unrestricted cross-origin
accessible window property name</dfn> if it is "*closed*" or "*postMessage*".

7.2.3.12 <dfn lt="windowproxy-same-coop-key">WindowProxyHasSameCOOPKey(W)</dfn>
	 1. Return true if the [=current global object=]'s [=browsing
            context=]'s [=top-level browsing context=]'s [=bcg-coop-agent-cluster-key|COOP
            agent cluster key=] is *W*'s [=browsing
            context=]'s [=top-level browsing context=]'s [=bcg-coop-agent-cluster-key|COOP
            agent cluster key=].

</div>

### The Location interface ### {#coop-location-interface}

Modify step 2 of the [=location-getownproperty|GetOwnProperty=] algorithm:

<div class="monkey-patch">

2. Let *property* be [=CrossOriginGetOwnPropertyHelper=](this,P, true).

</div>

## Browsing contexts ## {#coop-browsing-contexts}

Add two new members to the definition of [=browsing context=]:

<div class="monkey-patch">

- A <dfn lt="bcg-coop-agent-cluster-key">COOP agent cluster key</dfn>, which is
  null or a [=coop-agent-cluster-key|COOP agent cluster key=], initially null. 
- A <dfn lt="virtual-coop-agent-cluster-key">virtual COOP agent cluster
  key</dfn>, which is null or null or a [=coop-agent-cluster-key|COOP agent
  cluster key=], initially null. This is used by [=report-only value|cross-origin
  opener policy reporting=], to keep track of the changes to agent cluster keying
  that would have happened if the report-only policy had been enforced.

</div>

### Grouping of browsing contexts ### {#coop-grouping-of-browsing-contexts}

## Agents and agent clusters ## {#coop-agent-clusters}

Add the following to the [=Integration with the JavaScript agent cluster
formalism=]:

<div class="monkey-patch">

A <dfn lt="coop-agent-cluster-key">COOP agent cluster key</dfn> is a [=tuple=]
of an [=origin=] and a [=cross-origin isolation mode=].

</div>

Change the definition of the [=agent cluster key=]:

<div class="monkey-patch">

An [=agent cluster key=] is either a [=site=], or a [=tuple origin=], or a
[=tuple=] of a [=tuple origin=] and a [=coop-agent-cluster-key|COOP agent
cluster key=].

</div>

Security considerations {#security}
=======================

Same-origin policy {#same-origin-policy}
------------

Our proposal creates an unprecedented possibility: that two same-origin
documents can reach one another but not have full access to each other. We
audited the spec to produce a list of all places with same-origin checks
relying on the assumption of full access. Some points worthy of attention:
- The location object is quite sensitive and many of its methods/members are
  same-origin only. It is purposefully excluded from the list of allowed
  attributes by restrict-properties. We do not think we should allow a normal
  page to navigate a crossOriginIsolated page.
- For similar reasons name targeting does not work across pages with COOP:
  restrict-properties.
- Javascript navigations are a big NO. They mean executing arbitrary javascript
  within the target frame. There should be no way to navigate a frame across
  the COOP: restrict-properties boundary given the restrictions above are put in
  place.

Cross-origin subframes opening popup {#cross-origin-subframes-popup}
------------

What happens when an iframe in a `COOP` page opens a popup? The initial empty
document created always inherits the origin of the iframe, while we would like
`COOP` to be inherited from the top-level document. This can create dangerous
discrepencies where we end up with a `crossOriginIsolated` initial empty
document of an arbitrary origin.

For `COOP: same-origin` we solved this problem by setting no-opener on any
popup opened from an iframe that is cross-origin to its top-level document.

### Requirements ### {#requirements}

For COOP: restrict-properties to work, we need:
- To be able to work with cross-origin iframes opening popups. These are common
  in the flow we're trying to address. 
- To use the standard COOP comparison rules for freshly opened popups on their
  first navigation. Currently we do not inherit COOP for fresh popups opened by
  cross-origin iframes. So it is always `unsafe-none` to X. This works for
  current COOP values:
  - `same-origin-allow-popups` behaves like `unsafe-none` with freshly opened popups.
  - `same-origin` opens such popups with no-opener.
  - It does not work with COOP: `restrict-properties` because we need to swap
    against `unsafe-none`.

We do not currently inherit COOP because it would mix the origin, inherited
from the iframe, with the COOP value, inherited from the top-level document.

![image](../resources/coop_inheritance_issue.jpg)  
*By simply inheriting, we break COOP. In this example, everything lives in the
same process, which should never be allowed.*

We use noopener because an initial empty documents from a different origin in
the same browsing context group, if crossOriginIsolated, could read the
top-level origin, bypassing the PermissionsPolicy that might have been set on
the iframe.

<img alt="coop inheritance permission bypass" src="./resources/coop_inheritance_permission_bypass.jpg"></img>

*By not using noopener, we've allowed the iframe to exploit crossOriginIsolated
APIs, bypassing the PermissionsPolicy set by the embedder.*


### Solution ### {#solution}

Our solution is to supplement the COOP structure with the origin that initially
set it. This way we prevent the mix-up of origins and COOP value. The COOP
origin is used exclusively by the COOP algorithm. Initial empty documents that
do not have matching origin and COOP origin cannot use crossOriginIsolated
APIs.

<img alt="coop inheritance proposal" src="./resources/coop_inheritance_proposal.jpg"></img>

*By supplementing COOP with the setting origin, we are able to correctly
separate the two end pages in two distinct browsing context groups. The initial
empty document still lives in the opener browsing context group but might not
use CrossOriginIsolated APIs.*


We also wanted to add some details about the crossOriginIsolated APIs
restriction for pages with mismatched COOP origin and origin. Below are all the
different inherited pieces of the puzzle:

<img alt="coop inheritance coep1" src="./resources/coop_inheritance_coep_1.jpg"></img>

*COOP is inherited from the top-level opener browsing context. COEP gets passed
to the initial empty document because the iframe set it. crossOriginIsolated
permission is none because COOP origin and origin do not match.*

In this example, we have documents with different top-level origins in a
BrowsingContext group that is crossOriginIsolated. This was not initially
possible, but we believe this is fine:
- Anything that the iframe does is readable by a.com. This is fine because
  b.com agreed to that by setting COEP. The fresh popup is required to be
  in-process, and anything done in there can be read by a.com. A.com cannot get
  any extra information, because the top-level frame behaves like the iframe. It
  has COEP so it cannot do new embedding, it has the same origin so it cannot do
  extra fetches, etc.
- In the other direction, b.com can read a.com if the Permissions-Policy is
  delegated to the iframe. Permissions-Policy is not inherited. For this reason
  we explicitely disable crossOriginIsolated permission on all freshly opened
  popups, as it would otherwise default to `allow`.
- COOP invariants about top-level origins become invariants about top-level
  COOP origins. The only case where a page can have a COOP origin not equal to
  its actual origin is the initial empty document.

Finally, a note about the following situation:

<img alt="coop inheritance coep2" src="./resources/coop_inheritance_coep_2.jpg"></img>

*COEP gets inherited to the popup although only the iframe set it and its
top-level document did not. The iframe is NOT crossOriginIsolated.*

We've simplified the COOP value in the drawings. In reality it is augmented
with COEP when it is received from the network, and used alone in the COOP
algorithm. In the above picture it still works as intended, because we're
inheriting COOP: "restrict-properties" and not "restrict-properties+COEP".

### Origin and CSP ### {#origin-and-csp}
Because we're recording the origin along the COOP value, we need to decide what
to do with sandboxing, which can make the origin opaque. The current spec
mentions that we first compute the sandboxing flags, both inherited and set via
CSP, and then if COOP is also set we go to an error page. However, COOP
is enforced but CSP is not, creating a discrepency.

For COOP restrict-properties, we believe we should compute sandbox flags at
each redirect step, and use the potentially opaque origin to make COOP switch
decisions. Unlike regular COOP, having both sandbox flags and COOP
restrict-properties should not result in an error page. Instead, both sandbox
flags and COOP restrict-properties will apply.

Window.name leakage {#window-name-leakage}
------------

When we navigate to a COOP: restrict-properties page and then to a COOP:
unsafe-none page, we need to make sure no state remains from the previous
context, to limit XS-Leaks. Window.name can be set by a crossOriginIsolated
page and it could expose information to the next site.

<img alt="auth provider flow" src="./resources/name.jpg"></img>

*In this example all the documents with origin A.com can set and target the
window.name property. It is in a different context from the B.com's page, so we
stash the name when navigating. B.com free to set its own name and use it in
its context. When we navigate back to A.com we reuse the stashed name.*

### Window name leak ### {#window-name-leak}

`name` is a same-origin property of the Window object. While it cannot ever be
set or read directly by windows in other browsing context groups, it has the
particularity of being sticky, even during cross-browsing context group
navigations.

<img alt="window name leak" src="./resources/window_name_leak.jpg"></img>

*Because the property is linked to the window and not the document, this can be
a cross-site leak vector. In this example, the original A.com page, a
potentially crossOriginIsolated page was able to read the window's name.*

It is commonly used for named targetting, which is specifying a string as the
"target" of an anchor tag, a `window.open()` parameter, etc. to navigate that
target, or retrieve a window handle to it. This also has its own problems,
because we do not want a regular page to be able to navigate a
crossOriginIsolated page ever. Named targeting resulting in navigations are
therefore completely prohibited between browsing context groups. Window
retrieval is similarly not permitted because it would be an XS Leak vector, and
many queries could be used to guess a window's name.

<img alt="named targeting" src="./resources/named_targeting.jpg"></img>

*After a same-origin navigation of the opener, it tries to retrieve a handle to
the popup previously opened.*

### Short term mitigation ### {#short-term-mitigation}

A simple solution to this problem is to clear the window's name during a
navigation to a different browsing context group in the same COOP group.

<img alt="window name clear" src="./resources/window_name_clear.jpg"></img>

*In that case, the popup name is cleared when navigating to B.com. When it
navigates back to A.com, the name is cleared again.*

This interacts with named targetting, as the name is cleared, targetting cannot
resolve between the main page and the popup after it is navigated. The popup
has to manually update its name to something known by the main page.

### Long term mitigation ### {#long-term-mitigation}

We would prefer a solution that does not interact with named targetting, and
makes it easier and more robust for web developers to use named targeting with
multiple browsing context groups. An option would be to move from a single name
model to a multiple name model. In that case, each browsing context would have
a name per browsing context group that wants to refer to it.

<img alt="name per bcg" src="./resources/name_per_bcg.jpg"></img>

*Instead of clearing window.name, we link it to the browsing context group that
set it. Named targeting resolves if a page from A.com's browsing context group
targets the popup using 'myname'. B.com's browsing context group on the other
hand still sees the name as empty. After it sets a name of its own, it can be
used in B.com's browsing context without overriding A.com's set name.*

With this solution, we preserve legitimate use cases. We still need to block
named targetting which result in a navigation in a window in another browsing
context group. Note that this mechanism could also be used for browsing context
groups swaps to another COOP group, and to help restore names on back
navigation for example.

